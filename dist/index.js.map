{"version":3,"file":"index.js","sources":["../src/index.js"],"sourcesContent":["const computedStack = []\nconst observersMap = new WeakMap()\n\n/* Tools */\n\nconst isObj = function(o) { return o && typeof o === 'object' }\nconst isArray = Array.isArray\nconst defineBubblingProperties = function(object, key, parent) {\n    Object.defineProperty(object, '__key', { value: key, enumerable: false, configurable: true })\n    Object.defineProperty(object, '__parent', { value: parent, enumerable: false, configurable: true })\n}\n\nconst batcher = {\n    timeout: null,\n    queue: new Set(),\n    process() {\n        for(const task of batcher.queue)\n            task()\n        batcher.queue.clear()\n        batcher.timeout = null\n    },\n    enqueue(task) {\n        if(batcher.timeout === null)\n            batcher.timeout = setTimeout(batcher.process, 0)\n        batcher.queue.add(task)\n    }\n}\n\n/* Computed */\n\nfunction computed(wrappedFunction, { autoRun = true, callback, bind } = {}) {\n    // Proxify the function in order to intercept the calls\n    const proxy = new Proxy(wrappedFunction, {\n        apply(target, thisArg, argsList) {\n            const observeComputation = function(f) {\n                // Store into the stack a reference to the computed function\n                computedStack.unshift(callback || proxy)\n                // Run the computed function - or the async function\n                const result = f ?\n                    f() :\n                    target.apply(bind || thisArg, argsList)\n                // Remove the reference\n                computedStack.shift()\n                // Return the result\n                return result\n            }\n\n            // Inject the computeAsync argument which is used to manually declare when the computation takes part\n            argsList.push({\n                computeAsync: function(target) { return observeComputation(target) }\n            })\n\n            return observeComputation()\n        }\n    })\n    // If autoRun, then call the function at once\n    if(autoRun)\n        proxy()\n    return proxy\n}\n\n/* Dispose */\n\n// The disposed flag which is used to remove a computed function reference pointer\nfunction dispose(_) { return _.__disposed = true }\n\n/* Observe */\n\nfunction observe(obj, options = {}) {\n    const {\n        props,\n        ignore,\n        batch,\n        deep,\n        handler,\n        bind\n    } = options\n\n    // Ignore if the object is already observed\n    if(obj.__observed)\n        return obj\n\n    // Add the object to the observers map.\n    // observersMap signature : Map<Object, Map<Property, Set<Computed function>>>\n    // In other words, observersMap is a map of observed objects.\n    // For each observed object, each property is mapped with a set of computed functions depending on this property.\n    // Whenever a property is set, we re-run each one of the functions stored inside the matching Set.\n    observersMap.set(obj, new Map())\n\n    // If the deep flag is set, observe nested objects/arrays\n    if(deep) {\n        Object.entries(obj).forEach(function([key, val]) {\n            if(isObj(val)) {\n                obj[key] = observe(val, options)\n                // If a handler is set, we add keys to the object used to bubble up the mutation\n                if(handler)\n                    defineBubblingProperties(obj[key], key, obj)\n            }\n        })\n    }\n\n    // Proxify the object in order to intercept get/set on props\n    const proxy = new Proxy(obj, {\n        get(_, prop) {\n            if(prop === '__observed')\n                return true\n\n            // If the prop is watched\n            if((!props || props.includes(prop)) && (!ignore || !ignore.includes(prop))) {\n                // If a computed function is being run\n                if(computedStack.length) {\n                    const propertiesMap = observersMap.get(obj)\n                    if(!propertiesMap.has(prop))\n                        propertiesMap.set(prop, new Set())\n                    // Link the computed function and the property being accessed\n                    propertiesMap.get(prop).add(computedStack[0])\n                }\n            }\n\n            return obj[prop]\n        },\n        set(_, prop, value) {\n            const propertiesMap = observersMap.get(obj)\n\n            // If the prop is ignored\n            if(props && !props.includes(prop) || ignore && ignore.includes(prop)) {\n                obj[prop] = value\n                return true\n            }\n\n            // If the new/old value are equal, return\n            if((!isArray(obj) || prop !== 'length') && obj[prop] === value) return true\n            // If the deep flag is set we observe the newly set value\n            obj[prop] = deep && isObj(value) ? observe(value, options) : value\n            // If we defined a handler, we define the bubbling keys recursively on the new value\n            handler && deep && isObj(value) && defineBubblingProperties(obj[prop], prop, obj)\n\n            if(handler) {\n                // Retrieve the mutated properties chain & call the handler\n                const ancestry = [ prop ]\n                let parent = obj\n                while(parent.__key && parent.__parent) {\n                    ancestry.unshift(parent.__key)\n                    parent = parent.__parent\n                }\n                handler(ancestry, value, proxy)\n            }\n\n            if(propertiesMap.has(prop)) {\n                // Retrieve the computed functions depending on the prop\n                const dependents = propertiesMap.get(prop)\n                for(const dependent of dependents) {\n                    // If disposed, delete the function reference\n                    if(dependent.__disposed) {\n                        dependents.delete(dependent)\n                    } else if(dependent !== computedStack[0]) {\n                        // Run the computed function\n                        if(batch) batcher.enqueue(dependent)\n                        else dependent()\n                    }\n                }\n            }\n\n            return true\n        }\n    })\n\n    if(bind) {\n        // Need this for binding es6 classes methods which are stored in the object prototype\n        const methods = [\n            ...Object.getOwnPropertyNames(obj),\n            ...Object.getOwnPropertyNames(Object.getPrototypeOf(obj))\n        ].filter(prop => prop !== 'constructor' && typeof obj[prop] === 'function')\n        methods.forEach(key => obj[key] = obj[key].bind(proxy))\n    }\n\n    return proxy\n}\n\nexport default {\n    observe,\n    computed,\n    dispose\n}"],"names":["computedStack","observersMap","WeakMap","isObj","o","isArray","Array","defineBubblingProperties","object","key","parent","Object","defineProperty","value","enumerable","configurable","batcher","timeout","queue","Set","[object Object]","task","clear","setTimeout","process","add","observe","obj","options","props","ignore","batch","deep","handler","bind","__observed","set","Map","entries","forEach","val","proxy","Proxy","_","prop","includes","length","propertiesMap","get","has","ancestry","__key","__parent","unshift","dependents","dependent","__disposed","delete","enqueue","getOwnPropertyNames","getPrototypeOf","filter","computed","wrappedFunction","autoRun","callback","target","thisArg","argsList","observeComputation","f","result","apply","shift","push","computeAsync","dispose"],"mappings":"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"}